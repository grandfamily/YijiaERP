# ä¸€å®¶ç™¾è´§é‡‡è´­ç®¡ç†ç³»ç»Ÿ - ç¬¬ä¸€æ‰¹ï¼šåŸºç¡€æ¶æ„è¯¦ç»†éœ€æ±‚æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯
- **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
- **ç¼–å†™æ—¥æœŸ**: 2025å¹´8æœˆ11æ—¥
- **é€‚ç”¨èŒƒå›´**: ç³»ç»ŸåŸºç¡€æ¶æ„æ¨¡å—
- **ä¾èµ–å…³ç³»**: æ— ï¼ˆç³»ç»ŸåŸºç¡€ï¼‰

---

## ğŸ—ï¸ 1. ç”¨æˆ·è®¤è¯ä¸æƒé™ç³»ç»Ÿ (`auth/`)

### 1.1 æ¨¡å—æ¦‚è¿°
ç”¨æˆ·è®¤è¯ç³»ç»Ÿè´Ÿè´£ç”¨æˆ·ç™»å½•ã€æƒé™éªŒè¯ã€è§’è‰²ç®¡ç†ç­‰æ ¸å¿ƒå®‰å…¨åŠŸèƒ½ã€‚

### 1.2 ç»„ä»¶æ¶æ„

#### 1.2.1 LoginForm ç»„ä»¶
```typescript
// src/components/auth/LoginForm.tsx
interface LoginFormProps {
  onLoginSuccess: (user: User) => void;
  onLoginError: (error: string) => void;
}

interface LoginFormState {
  email: string;
  password: string;
  isLoading: boolean;
  error: string | null;
  rememberMe: boolean;
}

const LoginForm: React.FC<LoginFormProps> = ({ onLoginSuccess, onLoginError }) => {
  // çŠ¶æ€ç®¡ç†
  const [formData, setFormData] = useState<LoginFormState>({
    email: '',
    password: '',
    isLoading: false,
    error: null,
    rememberMe: false
  });

  // è¡¨å•éªŒè¯è§„åˆ™
  const validateForm = (): boolean => {
    if (!formData.email.trim()) {
      setFormData(prev => ({ ...prev, error: 'è¯·è¾“å…¥é‚®ç®±åœ°å€' }));
      return false;
    }
    if (!isValidEmail(formData.email)) {
      setFormData(prev => ({ ...prev, error: 'é‚®ç®±æ ¼å¼ä¸æ­£ç¡®' }));
      return false;
    }
    if (!formData.password.trim()) {
      setFormData(prev => ({ ...prev, error: 'è¯·è¾“å…¥å¯†ç ' }));
      return false;
    }
    if (formData.password.length < 6) {
      setFormData(prev => ({ ...prev, error: 'å¯†ç è‡³å°‘6ä½' }));
      return false;
    }
    return true;
  };

  // ç™»å½•å¤„ç†å‡½æ•°
  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!validateForm()) return;

    setFormData(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      // æ¨¡æ‹Ÿç™»å½•APIè°ƒç”¨
      const user = await authenticateUser(formData.email, formData.password);
      
      // æŒä¹…åŒ–ç™»å½•çŠ¶æ€
      if (formData.rememberMe) {
        localStorage.setItem('authToken', user.token);
        localStorage.setItem('userData', JSON.stringify(user));
      } else {
        sessionStorage.setItem('authToken', user.token);
        sessionStorage.setItem('userData', JSON.stringify(user));
      }

      onLoginSuccess(user);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'ç™»å½•å¤±è´¥ï¼Œè¯·é‡è¯•';
      setFormData(prev => ({ ...prev, error: errorMessage }));
      onLoginError(errorMessage);
    } finally {
      setFormData(prev => ({ ...prev, isLoading: false }));
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            ä¸€å®¶ç™¾è´§é‡‡è´­ç®¡ç†ç³»ç»Ÿ
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600">
            è¯·ä½¿ç”¨æ‚¨çš„è´¦æˆ·ç™»å½•
          </p>
        </div>
        <form className="mt-8 space-y-6" onSubmit={handleLogin}>
          {formData.error && (
            <div className="bg-red-50 border border-red-200 text-red-600 px-4 py-3 rounded">
              {formData.error}
            </div>
          )}
          
          <div className="space-y-4">
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-700">
                é‚®ç®±åœ°å€
              </label>
              <input
                id="email"
                name="email"
                type="email"
                required
                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                placeholder="è¯·è¾“å…¥é‚®ç®±åœ°å€"
                value={formData.email}
                onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value, error: null }))}
                disabled={formData.isLoading}
              />
            </div>
            
            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700">
                å¯†ç 
              </label>
              <input
                id="password"
                name="password"
                type="password"
                required
                className="mt-1 appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-blue-500 focus:border-blue-500 focus:z-10 sm:text-sm"
                placeholder="è¯·è¾“å…¥å¯†ç "
                value={formData.password}
                onChange={(e) => setFormData(prev => ({ ...prev, password: e.target.value, error: null }))}
                disabled={formData.isLoading}
              />
            </div>
          </div>

          <div className="flex items-center justify-between">
            <div className="flex items-center">
              <input
                id="remember-me"
                name="remember-me"
                type="checkbox"
                className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                checked={formData.rememberMe}
                onChange={(e) => setFormData(prev => ({ ...prev, rememberMe: e.target.checked }))}
              />
              <label htmlFor="remember-me" className="ml-2 block text-sm text-gray-900">
                è®°ä½æˆ‘
              </label>
            </div>
          </div>

          <div>
            <button
              type="submit"
              disabled={formData.isLoading}
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {formData.isLoading ? (
                <span className="flex items-center">
                  <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  ç™»å½•ä¸­...
                </span>
              ) : (
                'ç™»å½•'
              )}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};
```

#### 1.2.2 useAuth Hook
```typescript
// src/hooks/useAuth.ts
interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
}

interface AuthContextValue extends AuthState {
  login: (email: string, password: string, rememberMe?: boolean) => Promise<void>;
  logout: () => void;
  checkPermission: (requiredRole: UserRole | UserRole[]) => boolean;
  refreshUser: () => Promise<void>;
}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, setState] = useState<AuthState>({
    user: null,
    isAuthenticated: false,
    isLoading: true,
    error: null
  });

  // åˆå§‹åŒ–è®¤è¯çŠ¶æ€
  useEffect(() => {
    initializeAuth();
  }, []);

  const initializeAuth = async () => {
    try {
      const token = localStorage.getItem('authToken') || sessionStorage.getItem('authToken');
      const userData = localStorage.getItem('userData') || sessionStorage.getItem('userData');

      if (token && userData) {
        const user = JSON.parse(userData);
        // éªŒè¯tokenæœ‰æ•ˆæ€§
        if (await validateToken(token)) {
          setState({
            user,
            isAuthenticated: true,
            isLoading: false,
            error: null
          });
        } else {
          // Tokenæ— æ•ˆï¼Œæ¸…é™¤å­˜å‚¨
          clearAuthStorage();
          setState({
            user: null,
            isAuthenticated: false,
            isLoading: false,
            error: null
          });
        }
      } else {
        setState(prev => ({ ...prev, isLoading: false }));
      }
    } catch (error) {
      console.error('Auth initialization error:', error);
      setState({
        user: null,
        isAuthenticated: false,
        isLoading: false,
        error: 'è®¤è¯åˆå§‹åŒ–å¤±è´¥'
      });
    }
  };

  const login = async (email: string, password: string, rememberMe = false) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      const user = await authenticateUser(email, password);
      
      // å­˜å‚¨è®¤è¯ä¿¡æ¯
      const storage = rememberMe ? localStorage : sessionStorage;
      storage.setItem('authToken', user.token);
      storage.setItem('userData', JSON.stringify(user));

      setState({
        user,
        isAuthenticated: true,
        isLoading: false,
        error: null
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'ç™»å½•å¤±è´¥';
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: errorMessage
      }));
      throw error;
    }
  };

  const logout = () => {
    clearAuthStorage();
    setState({
      user: null,
      isAuthenticated: false,
      isLoading: false,
      error: null
    });
  };

  const checkPermission = (requiredRole: UserRole | UserRole[]): boolean => {
    if (!state.user) return false;

    const roles = Array.isArray(requiredRole) ? requiredRole : [requiredRole];
    return roles.includes(state.user.role);
  };

  const refreshUser = async () => {
    if (!state.user) return;

    try {
      const updatedUser = await fetchUserById(state.user.id);
      setState(prev => ({ ...prev, user: updatedUser }));
    } catch (error) {
      console.error('Failed to refresh user:', error);
    }
  };

  const value: AuthContextValue = {
    ...state,
    login,
    logout,
    checkPermission,
    refreshUser
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = (): AuthContextValue => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
```

### 1.3 æƒé™æ§åˆ¶ç»„ä»¶

#### 1.3.1 ProtectedRoute ç»„ä»¶
```typescript
// src/components/auth/ProtectedRoute.tsx
interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRole?: UserRole | UserRole[];
  fallback?: React.ReactNode;
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  children, 
  requiredRole, 
  fallback 
}) => {
  const { isAuthenticated, isLoading, checkPermission } = useAuth();

  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-600"></div>
      </div>
    );
  }

  if (!isAuthenticated) {
    return <LoginForm onLoginSuccess={() => {}} onLoginError={() => {}} />;
  }

  if (requiredRole && !checkPermission(requiredRole)) {
    return fallback || (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <h2 className="text-2xl font-bold text-gray-900 mb-4">è®¿é—®è¢«æ‹’ç»</h2>
          <p className="text-gray-600">æ‚¨æ²¡æœ‰è®¿é—®æ­¤é¡µé¢çš„æƒé™</p>
        </div>
      </div>
    );
  }

  return <>{children}</>;
};
```

### 1.4 è®¤è¯æœåŠ¡å‡½æ•°

#### 1.4.1 è®¤è¯APIæ¨¡æ‹Ÿ
```typescript
// src/services/authService.ts
interface AuthResponse {
  user: User;
  token: string;
  expiresAt: Date;
}

// æ¨¡æ‹Ÿç”¨æˆ·æ•°æ®åº“
const MOCK_USERS: Array<User & { password: string; token: string }> = [
  {
    id: 'user-001',
    name: 'å¼ é‡‡è´­',
    email: 'zhang@company.com',
    password: '123456',
    role: 'purchasing_officer',
    department: 'é‡‡è´­éƒ¨',
    isActive: true,
    createdAt: new Date('2024-01-01'),
    token: 'token-zhang-001'
  },
  {
    id: 'user-002',
    name: 'æä¸»ç®¡',
    email: 'li@company.com',
    password: '123456',
    role: 'department_manager',
    department: 'é‡‡è´­éƒ¨',
    isActive: true,
    createdAt: new Date('2024-01-01'),
    token: 'token-li-002'
  },
  {
    id: 'user-003',
    name: 'ç‹æ€»ç»ç†',
    email: 'wang@company.com',
    password: '123456',
    role: 'general_manager',
    department: 'ç®¡ç†å±‚',
    isActive: true,
    createdAt: new Date('2024-01-01'),
    token: 'token-wang-003'
  },
  // æ›´å¤šç”¨æˆ·è§’è‰²...
  {
    id: 'user-004',
    name: 'èµµè®¾è®¡',
    email: 'zhao@company.com',
    password: '123456',
    role: 'card_designer',
    department: 'è®¾è®¡éƒ¨',
    isActive: true,
    createdAt: new Date('2024-01-01'),
    token: 'token-zhao-004'
  },
  {
    id: 'user-005',
    name: 'é’±ç”Ÿäº§',
    email: 'qian@company.com',
    password: '123456',
    role: 'production_staff',
    department: 'ç”Ÿäº§éƒ¨',
    isActive: true,
    createdAt: new Date('2024-01-01'),
    token: 'token-qian-005'
  }
];

export const authenticateUser = async (email: string, password: string): Promise<AuthResponse> => {
  // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
  await new Promise(resolve => setTimeout(resolve, 1000));

  const user = MOCK_USERS.find(u => u.email === email && u.password === password);
  
  if (!user) {
    throw new Error('é‚®ç®±æˆ–å¯†ç é”™è¯¯');
  }

  if (!user.isActive) {
    throw new Error('è´¦æˆ·å·²è¢«ç¦ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜');
  }

  const { password: _, ...userWithoutPassword } = user;
  
  return {
    user: userWithoutPassword,
    token: user.token,
    expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24å°æ—¶åè¿‡æœŸ
  };
};

export const validateToken = async (token: string): Promise<boolean> => {
  // æ¨¡æ‹ŸtokenéªŒè¯
  await new Promise(resolve => setTimeout(resolve, 200));
  
  return MOCK_USERS.some(user => user.token === token);
};

export const fetchUserById = async (userId: string): Promise<User> => {
  await new Promise(resolve => setTimeout(resolve, 300));
  
  const user = MOCK_USERS.find(u => u.id === userId);
  if (!user) {
    throw new Error('ç”¨æˆ·ä¸å­˜åœ¨');
  }

  const { password: _, token: __, ...userWithoutSensitiveData } = user;
  return userWithoutSensitiveData;
};

// æƒé™æ£€æŸ¥è¾…åŠ©å‡½æ•°
export const hasPermission = (userRole: UserRole, requiredRole: UserRole | UserRole[]): boolean => {
  const roles = Array.isArray(requiredRole) ? requiredRole : [requiredRole];
  return roles.includes(userRole);
};

// è§’è‰²å±‚çº§å®šä¹‰ï¼ˆç”¨äºæƒé™ç»§æ‰¿ï¼‰
export const ROLE_HIERARCHY: Record<UserRole, number> = {
  'general_manager': 10,      // æœ€é«˜æƒé™
  'department_manager': 8,    // éƒ¨é—¨ç®¡ç†æƒé™
  'purchasing_officer': 6,    // é‡‡è´­ä¸“å‘˜æƒé™
  'finance_personnel': 6,     // è´¢åŠ¡äººå‘˜æƒé™
  'warehouse_staff': 5,       // ä»“ç®¡æƒé™
  'logistics_staff': 5,       // ç‰©æµæƒé™
  'production_staff': 4,      // ç”Ÿäº§æƒé™
  'card_designer': 4,         // è®¾è®¡æƒé™
  'accessory_staff': 4,       // è¾…æ–™æƒé™
  'qc_officer': 4,           // è´¨æ£€æƒé™
};

export const hasRolePermission = (userRole: UserRole, minimumRole: UserRole): boolean => {
  return ROLE_HIERARCHY[userRole] >= ROLE_HIERARCHY[minimumRole];
};

// æ¸…é™¤è®¤è¯å­˜å‚¨
export const clearAuthStorage = (): void => {
  localStorage.removeItem('authToken');
  localStorage.removeItem('userData');
  sessionStorage.removeItem('authToken');
  sessionStorage.removeItem('userData');
};

// é‚®ç®±æ ¼å¼éªŒè¯
export const isValidEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};
```

---

## ğŸ—„ï¸ 2. å…¨å±€çŠ¶æ€ç®¡ç† (`store/`)

### 2.1 æ¨¡å—æ¦‚è¿°
åŸºäºZustandçš„å…¨å±€çŠ¶æ€ç®¡ç†ï¼Œæä¾›ç±»å‹å®‰å…¨çš„çŠ¶æ€æ›´æ–°å’ŒæŒä¹…åŒ–åŠŸèƒ½ã€‚

### 2.2 æ ¸å¿ƒStoreè®¾è®¡

#### 2.2.1 å…¨å±€Storeç»“æ„
```typescript
// src/store/globalStore.ts
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { persist } from 'zustand/middleware';

// å…¨å±€çŠ¶æ€æ¥å£å®šä¹‰
interface GlobalStoreState {
  // === ç”¨æˆ·ç®¡ç† ===
  user: User | null;
  setUser: (user: User | null) => void;
  
  // === é‡‡è´­ç”³è¯·ç®¡ç† ===
  purchaseRequests: PurchaseRequest[];
  setPurchaseRequests: (requests: PurchaseRequest[]) => void;
  addPurchaseRequest: (request: PurchaseRequest) => void;
  updatePurchaseRequest: (id: string, updates: Partial<PurchaseRequest>) => void;
  deletePurchaseRequest: (id: string) => void;
  
  // === è®¢å•åˆ†é…ç®¡ç† ===
  orderAllocations: OrderAllocation[];
  setOrderAllocations: (allocations: OrderAllocation[]) => void;
  addOrderAllocation: (allocation: OrderAllocation) => void;
  updateOrderAllocation: (id: string, updates: Partial<OrderAllocation>) => void;
  
  // === é‡‡è´­è¿›åº¦ç®¡ç† ===
  procurementProgress: ProcurementProgress[];
  setProcurementProgress: (progress: ProcurementProgress[]) => void;
  addProcurementProgress: (progress: ProcurementProgress) => void;
  updateProcurementProgress: (id: string, updates: Partial<ProcurementProgress>) => void;
  
  // === çº¸å¡è¿›åº¦ç®¡ç† ===
  cardProgress: CardProgress[];
  setCardProgress: (progress: CardProgress[]) => void;
  addCardProgress: (progress: CardProgress) => void;
  updateCardProgress: (id: string, updates: Partial<CardProgress>) => void;
  
  // === è¾…æ–™è¿›åº¦ç®¡ç† ===
  accessoryProgress: AccessoryProgress[];
  setAccessoryProgress: (progress: AccessoryProgress[]) => void;
  addAccessoryProgress: (progress: AccessoryProgress) => void;
  updateAccessoryProgress: (id: string, updates: Partial<AccessoryProgress>) => void;
  
  // === åˆ°è´§æ£€éªŒç®¡ç† ===
  arrivalInspections: ArrivalInspection[];
  setArrivalInspections: (inspections: ArrivalInspection[]) => void;
  addArrivalInspection: (inspection: ArrivalInspection) => void;
  updateArrivalInspection: (id: string, updates: Partial<ArrivalInspection>) => void;
  
  // === ç”Ÿäº§æ’å•ç®¡ç† ===
  productionSchedules: ProductionSchedule[];
  setProductionSchedules: (schedules: ProductionSchedule[]) => void;
  addProductionSchedule: (schedule: ProductionSchedule) => void;
  updateProductionSchedule: (id: string, updates: Partial<ProductionSchedule>) => void;
  
  // === å…¥åº“ç™»è®°ç®¡ç† ===
  inboundRegisters: InboundRegisterRecord[];
  setInboundRegisters: (registers: InboundRegisterRecord[]) => void;
  addInboundRegister: (register: InboundRegisterRecord) => void;
  updateInboundRegister: (id: string, updates: Partial<InboundRegisterRecord>) => void;
  
  // === è´¨æ£€ç®¡ç† ===
  qualityControlRecords: QualityControlRecord[];
  setQualityControlRecords: (records: QualityControlRecord[]) => void;
  addQualityControlRecord: (record: QualityControlRecord) => void;
  updateQualityControlRecord: (id: string, updates: Partial<QualityControlRecord>) => void;
  
  // === ä¸åˆæ ¼è®¢å•ç®¡ç† ===
  rejectedOrders: RejectedOrder[];
  setRejectedOrders: (orders: RejectedOrder[]) => void;
  addRejectedOrder: (order: RejectedOrder) => void;
  updateRejectedOrder: (id: string, updates: Partial<RejectedOrder>) => void;
  
  // === å‘è´§ç®¡ç† ===
  shipments: Shipment[];
  setShipments: (shipments: Shipment[]) => void;
  addShipment: (shipment: Shipment) => void;
  updateShipment: (id: string, updates: Partial<Shipment>) => void;
  
  // === åº“å­˜ç®¡ç† ===
  inventory: InventoryItem[];
  setInventory: (items: InventoryItem[]) => void;
  addInventoryItem: (item: InventoryItem) => void;
  updateInventoryItem: (id: string, updates: Partial<InventoryItem>) => void;
  
  // === é€šç”¨æ“ä½œ ===
  resetStore: () => void;
  initializeStore: () => Promise<void>;
}

// åˆ›å»ºå…¨å±€Store
export const useGlobalStore = create<GlobalStoreState>()(
  subscribeWithSelector(
    persist(
      (set, get) => ({
        // === åˆå§‹çŠ¶æ€ ===
        user: null,
        purchaseRequests: [],
        orderAllocations: [],
        procurementProgress: [],
        cardProgress: [],
        accessoryProgress: [],
        arrivalInspections: [],
        productionSchedules: [],
        inboundRegisters: [],
        qualityControlRecords: [],
        rejectedOrders: [],
        shipments: [],
        inventory: [],

        // === ç”¨æˆ·ç®¡ç†æ“ä½œ ===
        setUser: (user) => set({ user }),

        // === é‡‡è´­ç”³è¯·æ“ä½œ ===
        setPurchaseRequests: (requests) => set({ purchaseRequests: requests }),
        
        addPurchaseRequest: (request) => set((state) => ({
          purchaseRequests: [...state.purchaseRequests, request]
        })),
        
        updatePurchaseRequest: (id, updates) => set((state) => ({
          purchaseRequests: state.purchaseRequests.map(req =>
            req.id === id ? { ...req, ...updates, updatedAt: new Date() } : req
          )
        })),
        
        deletePurchaseRequest: (id) => set((state) => ({
          purchaseRequests: state.purchaseRequests.filter(req => req.id !== id)
        })),

        // === è®¢å•åˆ†é…æ“ä½œ ===
        setOrderAllocations: (allocations) => set({ orderAllocations: allocations }),
        
        addOrderAllocation: (allocation) => set((state) => ({
          orderAllocations: [...state.orderAllocations, allocation]
        })),
        
        updateOrderAllocation: (id, updates) => set((state) => ({
          orderAllocations: state.orderAllocations.map(alloc =>
            alloc.id === id ? { ...alloc, ...updates, updatedAt: new Date() } : alloc
          )
        })),

        // === é‡‡è´­è¿›åº¦æ“ä½œ ===
        setProcurementProgress: (progress) => set({ procurementProgress: progress }),
        
        addProcurementProgress: (progress) => set((state) => {
          // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒçš„è¿›åº¦è®°å½•
          const existingIndex = state.procurementProgress.findIndex(
            p => p.purchaseRequestId === progress.purchaseRequestId
          );
          
          if (existingIndex >= 0) {
            // æ›´æ–°å·²å­˜åœ¨çš„è®°å½•
            const updated = [...state.procurementProgress];
            updated[existingIndex] = { ...updated[existingIndex], ...progress };
            return { procurementProgress: updated };
          } else {
            // æ·»åŠ æ–°è®°å½•
            return { procurementProgress: [...state.procurementProgress, progress] };
          }
        }),
        
        updateProcurementProgress: (id, updates) => set((state) => ({
          procurementProgress: state.procurementProgress.map(prog =>
            prog.id === id ? { ...prog, ...updates, updatedAt: new Date() } : prog
          )
        })),

        // === çº¸å¡è¿›åº¦æ“ä½œ ===
        setCardProgress: (progress) => set({ cardProgress: progress }),
        
        addCardProgress: (progress) => set((state) => ({
          cardProgress: [...state.cardProgress, progress]
        })),
        
        updateCardProgress: (id, updates) => set((state) => ({
          cardProgress: state.cardProgress.map(prog =>
            prog.id === id ? { ...prog, ...updates, updatedAt: new Date() } : prog
          )
        })),

        // === è¾…æ–™è¿›åº¦æ“ä½œ ===
        setAccessoryProgress: (progress) => set({ accessoryProgress: progress }),
        
        addAccessoryProgress: (progress) => set((state) => ({
          accessoryProgress: [...state.accessoryProgress, progress]
        })),
        
        updateAccessoryProgress: (id, updates) => set((state) => ({
          accessoryProgress: state.accessoryProgress.map(prog =>
            prog.id === id ? { ...prog, ...updates, updatedAt: new Date() } : prog
          )
        })),

        // === åˆ°è´§æ£€éªŒæ“ä½œ ===
        setArrivalInspections: (inspections) => set({ arrivalInspections: inspections }),
        
        addArrivalInspection: (inspection) => set((state) => ({
          arrivalInspections: [...state.arrivalInspections, inspection]
        })),
        
        updateArrivalInspection: (id, updates) => set((state) => ({
          arrivalInspections: state.arrivalInspections.map(insp =>
            insp.id === id ? { ...insp, ...updates, updatedAt: new Date() } : insp
          )
        })),

        // === ç”Ÿäº§æ’å•æ“ä½œ ===
        setProductionSchedules: (schedules) => set({ productionSchedules: schedules }),
        
        addProductionSchedule: (schedule) => set((state) => ({
          productionSchedules: [...state.productionSchedules, schedule]
        })),
        
        updateProductionSchedule: (id, updates) => set((state) => ({
          productionSchedules: state.productionSchedules.map(sched =>
            sched.id === id ? { ...sched, ...updates, updatedAt: new Date() } : sched
          )
        })),

        // === å…¥åº“ç™»è®°æ“ä½œ ===
        setInboundRegisters: (registers) => set({ inboundRegisters: registers }),
        
        addInboundRegister: (register) => set((state) => {
          // é˜²æ­¢é‡å¤æ·»åŠ ç›¸åŒçš„å…¥åº“è®°å½•
          const exists = state.inboundRegisters.some(
            r => r.purchaseRequestNumber === register.purchaseRequestNumber && 
                 r.skuId === register.skuId
          );
          
          if (!exists) {
            return { inboundRegisters: [...state.inboundRegisters, register] };
          }
          return state;
        }),
        
        updateInboundRegister: (id, updates) => set((state) => ({
          inboundRegisters: state.inboundRegisters.map(reg =>
            reg.id === id ? { ...reg, ...updates, updatedAt: new Date() } : reg
          )
        })),

        // === è´¨æ£€æ“ä½œ ===
        setQualityControlRecords: (records) => set({ qualityControlRecords: records }),
        
        addQualityControlRecord: (record) => set((state) => {
          // é˜²æ­¢é‡å¤æ·»åŠ 
          const exists = state.qualityControlRecords.some(
            r => r.purchaseRequestNumber === record.purchaseRequestNumber && 
                 r.skuId === record.skuId
          );
          
          if (!exists) {
            return { qualityControlRecords: [...state.qualityControlRecords, record] };
          }
          return state;
        }),
        
        updateQualityControlRecord: (id, updates) => set((state) => ({
          qualityControlRecords: state.qualityControlRecords.map(rec =>
            rec.id === id ? { ...rec, ...updates, updatedAt: new Date() } : rec
          )
        })),

        // === ä¸åˆæ ¼è®¢å•æ“ä½œï¼ˆå¸¦æŒä¹…åŒ–ï¼‰ ===
        setRejectedOrders: (orders) => {
          try {
            localStorage.setItem('rejectedOrders', JSON.stringify(orders));
          } catch (error) {
            console.error('Failed to persist rejected orders:', error);
          }
          set({ rejectedOrders: orders });
        },
        
        addRejectedOrder: (order) => set((state) => {
          const newOrders = [...state.rejectedOrders, order];
          try {
            localStorage.setItem('rejectedOrders', JSON.stringify(newOrders));
          } catch (error) {
            console.error('Failed to persist rejected orders:', error);
          }
          return { rejectedOrders: newOrders };
        }),
        
        updateRejectedOrder: (id, updates) => set((state) => {
          const newOrders = state.rejectedOrders.map(order =>
            order.id === id ? { ...order, ...updates } : order
          );
          try {
            localStorage.setItem('rejectedOrders', JSON.stringify(newOrders));
          } catch (error) {
            console.error('Failed to persist rejected orders:', error);
          }
          return { rejectedOrders: newOrders };
        }),

        // === å‘è´§æ“ä½œ ===
        setShipments: (shipments) => set({ shipments }),
        
        addShipment: (shipment) => set((state) => ({
          shipments: [...state.shipments, shipment]
        })),
        
        updateShipment: (id, updates) => set((state) => ({
          shipments: state.shipments.map(ship =>
            ship.id === id ? { ...ship, ...updates, updatedAt: new Date() } : ship
          )
        })),

        // === åº“å­˜æ“ä½œ ===
        setInventory: (items) => set({ inventory: items }),
        
        addInventoryItem: (item) => set((state) => ({
          inventory: [...state.inventory, item]
        })),
        
        updateInventoryItem: (id, updates) => set((state) => ({
          inventory: state.inventory.map(item =>
            item.id === id ? { ...item, ...updates, updatedAt: new Date() } : item
          )
        })),

        // === é€šç”¨æ“ä½œ ===
        resetStore: () => set({
          user: null,
          purchaseRequests: [],
          orderAllocations: [],
          procurementProgress: [],
          cardProgress: [],
          accessoryProgress: [],
          arrivalInspections: [],
          productionSchedules: [],
          inboundRegisters: [],
          qualityControlRecords: [],
          rejectedOrders: [],
          shipments: [],
          inventory: []
        }),

        initializeStore: async () => {
          try {
            // ä»localStorageæ¢å¤ä¸åˆæ ¼è®¢å•æ•°æ®
            const storedRejectedOrders = localStorage.getItem('rejectedOrders');
            if (storedRejectedOrders) {
              const rejectedOrders = JSON.parse(storedRejectedOrders);
              set({ rejectedOrders });
            }

            // è¿™é‡Œå¯ä»¥æ·»åŠ å…¶ä»–æ•°æ®çš„åˆå§‹åŒ–é€»è¾‘
            // æ¯”å¦‚ä»APIåŠ è½½åŸºç¡€æ•°æ®ç­‰
            
          } catch (error) {
            console.error('Failed to initialize store:', error);
          }
        }
      }),
      {
        name: 'global-store',
        // åªæŒä¹…åŒ–éƒ¨åˆ†å…³é”®æ•°æ®
        partialize: (state) => ({
          user: state.user,
          rejectedOrders: state.rejectedOrders
        })
      }
    )
  )
);

// Storeæ“ä½œçš„è¾…åŠ©hooks
export const useStoreActions = () => {
  const store = useGlobalStore();
  
  return {
    // æ‰¹é‡æ“ä½œ
    batchUpdatePurchaseRequests: (updates: Array<{ id: string; updates: Partial<PurchaseRequest> }>) => {
      updates.forEach(({ id, updates: itemUpdates }) => {
        store.updatePurchaseRequest(id, itemUpdates);
      });
    },
    
    // çº§è”åˆ é™¤æ“ä½œ
    cascadeDeletePurchaseRequest: (requestId: string) => {
      // åˆ é™¤é‡‡è´­ç”³è¯·æ—¶ï¼ŒåŒæ—¶åˆ é™¤ç›¸å…³çš„è¿›åº¦è®°å½•
      store.deletePurchaseRequest(requestId);
      
      // åˆ é™¤ç›¸å…³çš„åˆ†é…è®°å½•
      const allocations = store.orderAllocations.filter(a => a.purchaseRequestId !== requestId);
      store.setOrderAllocations(allocations);
      
      // åˆ é™¤ç›¸å…³çš„è¿›åº¦è®°å½•
      const progress = store.procurementProgress.filter(p => p.purchaseRequestId !== requestId);
      store.setProcurementProgress(progress);
      
      // åˆ é™¤ç›¸å…³çš„çº¸å¡è¿›åº¦
      const cardProgress = store.cardProgress.filter(c => c.purchaseRequestId !== requestId);
      store.setCardProgress(cardProgress);
      
      // åˆ é™¤ç›¸å…³çš„è¾…æ–™è¿›åº¦
      const accessoryProgress = store.accessoryProgress.filter(a => a.purchaseRequestId !== requestId);
      store.setAccessoryProgress(accessoryProgress);
    },
    
    // çŠ¶æ€åŒæ­¥æ“ä½œ
    syncProgressStates: (requestId: string) => {
      // åŒæ­¥å„ä¸ªè¿›åº¦æ¨¡å—çš„çŠ¶æ€
      const procurement = store.procurementProgress.find(p => p.purchaseRequestId === requestId);
      const card = store.cardProgress.filter(c => c.purchaseRequestId === requestId);
      const accessory = store.accessoryProgress.filter(a => a.purchaseRequestId === requestId);
      
      // æ ¹æ®å„æ¨¡å—çŠ¶æ€æ›´æ–°é‡‡è´­ç”³è¯·çš„æ•´ä½“çŠ¶æ€
      // è¿™é‡Œå¯ä»¥å®ç°å¤æ‚çš„çŠ¶æ€åŒæ­¥é€»è¾‘
    }
  };
};

// é€‰æ‹©å™¨hooksï¼ˆç”¨äºæ€§èƒ½ä¼˜åŒ–ï¼‰
export const usePurchaseRequests = () => useGlobalStore(state => state.purchaseRequests);
export const useOrderAllocations = () => useGlobalStore(state => state.orderAllocations);
export const useProcurementProgress = () => useGlobalStore(state => state.procurementProgress);
export const useCardProgress = () => useGlobalStore(state => state.cardProgress);
export const useAccessoryProgress = () => useGlobalStore(state => state.accessoryProgress);
export const useArrivalInspections = () => useGlobalStore(state => state.arrivalInspections);
export const useProductionSchedules = () => useGlobalStore(state => state.productionSchedules);
export const useInboundRegisters = () => useGlobalStore(state => state.inboundRegisters);
export const useQualityControlRecords = () => useGlobalStore(state => state.qualityControlRecords);
export const useRejectedOrders = () => useGlobalStore(state => state.rejectedOrders);
export const useShipments = () => useGlobalStore(state => state.shipments);
export const useInventory = () => useGlobalStore(state => state.inventory);
```

### 2.3 ä¸“ç”¨Storeæ¨¡å—

#### 2.3.1 è´¨æ£€Store (è´¨é‡æ§åˆ¶)
```typescript
// src/store/qualityControl.ts
export interface QualityControlRecord {
  id: string;
  purchaseRequestNumber: string;
  skuId: string;
  sku: SKU;
  expectedQuantity: number;
  receivedQuantity: number;
  inspectionStatus: QualityInspectionStatus;
  inspectionDate: Date | null;
  inspectorId: string | null;
  inspector: User | null;
  packageCount: number;
  totalPieces: number;
  piecesPerUnit: number;
  boxLength: number;
  boxWidth: number;
  boxHeight: number;
  unitWeight: number;
  totalQuantity: number | null;
  boxVolume: number | null;
  totalVolume: number | null;
  totalWeight: number | null;
  qualityIssues: string[];
  remarks: string;
  photos: InspectionPhoto[];
  createdAt: Date;
  updatedAt: Date;
}

export type QualityInspectionStatus = 
  | 'pending'       // å¾…éªŒæ”¶
  | 'in_progress'   // éªŒæ”¶ä¸­
  | 'passed'        // å·²é€šè¿‡
  | 'failed'        // ä¸åˆæ ¼
  | 'returned';     // å·²é€€è´§

export interface InspectionPhoto {
  id: string;
  url: string;
  description?: string;
  uploadedAt: Date;
}

interface QualityControlState {
  records: QualityControlRecord[];
  setRecords: (records: QualityControlRecord[]) => void;
  addRecord: (record: QualityControlRecord) => void;
  updateRecord: (id: string, updates: Partial<QualityControlRecord>) => void;
  deleteRecord: (id: string) => void;
  
  // ç­›é€‰å’ŒæŸ¥è¯¢
  getRecordsByStatus: (status: QualityInspectionStatus) => QualityControlRecord[];
  getRecordsByPurchaseRequest: (purchaseRequestNumber: string) => QualityControlRecord[];
  getRecordsBySKU: (skuId: string) => QualityControlRecord[];
  
  // ç»Ÿè®¡åŠŸèƒ½
  getInspectionStats: () => {
    total: number;
    pending: number;
    inProgress: number;
    passed: number;
    failed: number;
    returned: number;
  };
  
  // æ‰¹é‡æ“ä½œ
  batchUpdateStatus: (ids: string[], status: QualityInspectionStatus) => void;
  batchAssignInspector: (ids: string[], inspectorId: string) => void;
}

export const useQualityControlStore = create<QualityControlState>()((set, get) => ({
  records: [],
  
  setRecords: (records) => set({ records }),
  
  addRecord: (record) => set((state) => ({
    records: [...state.records, record]
  })),
  
  updateRecord: (id, updates) => set((state) => ({
    records: state.records.map(record =>
      record.id === id 
        ? { ...record, ...updates, updatedAt: new Date() }
        : record
    )
  })),
  
  deleteRecord: (id) => set((state) => ({
    records: state.records.filter(record => record.id !== id)
  })),
  
  getRecordsByStatus: (status) => {
    return get().records.filter(record => record.inspectionStatus === status);
  },
  
  getRecordsByPurchaseRequest: (purchaseRequestNumber) => {
    return get().records.filter(record => record.purchaseRequestNumber === purchaseRequestNumber);
  },
  
  getRecordsBySKU: (skuId) => {
    return get().records.filter(record => record.skuId === skuId);
  },
  
  getInspectionStats: () => {
    const records = get().records;
    return {
      total: records.length,
      pending: records.filter(r => r.inspectionStatus === 'pending').length,
      inProgress: records.filter(r => r.inspectionStatus === 'in_progress').length,
      passed: records.filter(r => r.inspectionStatus === 'passed').length,
      failed: records.filter(r => r.inspectionStatus === 'failed').length,
      returned: records.filter(r => r.inspectionStatus === 'returned').length,
    };
  },
  
  batchUpdateStatus: (ids, status) => set((state) => ({
    records: state.records.map(record =>
      ids.includes(record.id)
        ? { 
            ...record, 
            inspectionStatus: status,
            inspectionDate: status !== 'pending' ? new Date() : null,
            updatedAt: new Date()
          }
        : record
    )
  })),
  
  batchAssignInspector: (ids, inspectorId) => set((state) => ({
    records: state.records.map(record =>
      ids.includes(record.id)
        ? { ...record, inspectorId, updatedAt: new Date() }
        : record
    )
  }))
}));
```

---

## ğŸ“‹ 3. ç±»å‹å®šä¹‰ç³»ç»Ÿ (`types/`)

### 3.1 æ¨¡å—æ¦‚è¿°
å®Œæ•´çš„TypeScriptç±»å‹å®šä¹‰ï¼Œç¡®ä¿æ•´ä¸ªç³»ç»Ÿçš„ç±»å‹å®‰å…¨ã€‚

### 3.2 æ ¸å¿ƒç±»å‹å®šä¹‰

#### 3.2.1 ç”¨æˆ·å’Œæƒé™ç±»å‹
```typescript
// src/types/auth.ts
export interface User {
  id: string;
  name: string;
  email: string;
  role: UserRole;
  department?: string;
  isActive: boolean;
  avatar?: string;
  phone?: string;
  lastLoginAt?: Date;
  createdAt: Date;
  updatedAt?: Date;
}

export type UserRole = 
  | 'purchasing_officer'    // é‡‡è´­ä¸“å‘˜
  | 'department_manager'    // éƒ¨é—¨ä¸»ç®¡
  | 'general_manager'       // æ€»ç»ç†
  | 'card_designer'         // çº¸å¡è®¾è®¡äººå‘˜
  | 'production_staff'      // ç”Ÿäº§æ’å•äººå‘˜
  | 'warehouse_staff'       // ä»“ç®¡äººå‘˜
  | 'logistics_staff'       // ç‰©æµä¸“å‘˜
  | 'finance_personnel'     // è´¢åŠ¡äººå‘˜
  | 'accessory_staff'       // è¾…æ–™äººå‘˜
  | 'qc_officer'           // è´¨æ£€ä¸“å‘˜
  | 'production_operator';  // ç”Ÿäº§æ“ä½œå‘˜

export interface Permission {
  id: string;
  name: string;
  code: string;
  description?: string;
  module: string;
  actions: PermissionAction[];
}

export type PermissionAction = 
  | 'create'    // åˆ›å»º
  | 'read'      // æŸ¥çœ‹
  | 'update'    // æ›´æ–°
  | 'delete'    // åˆ é™¤
  | 'approve'   // å®¡æ‰¹
  | 'assign'    // åˆ†é…
  | 'export';   // å¯¼å‡º

export interface RolePermission {
  role: UserRole;
  permissions: Permission[];
}
```

#### 3.2.2 äº§å“å’ŒSKUç±»å‹
```typescript
// src/types/product.ts
export interface SKU {
  id: string;
  code: string;                    // SKUç¼–ç 
  name: string;                    // äº§å“åç§°
  englishName?: string;            // è‹±æ–‡åç§°
  category: ProductCategory;       // äº§å“åˆ†ç±»
  identificationCode: string;      // è¯†åˆ«ç 
  imageUrl?: string;              // äº§å“å›¾ç‰‡URL
  description?: string;           // äº§å“æè¿°
  specifications?: ProductSpec[]; // äº§å“è§„æ ¼
  unit: string;                   // å•ä½
  weight?: number;                // é‡é‡(g)
  dimensions?: Dimensions;        // å°ºå¯¸
  materials?: string[];           // ææ–™
  colors?: string[];              // é¢œè‰²é€‰é¡¹
  packagingOptions?: PackagingOption[]; // åŒ…è£…é€‰é¡¹
  isActive: boolean;              // æ˜¯å¦å¯ç”¨
  createdAt: Date;
  updatedAt: Date;
}

export interface ProductCategory {
  id: string;
  name: string;
  code: string;
  parentId?: string;
  level: number;
  description?: string;
}

export interface ProductSpec {
  name: string;        // è§„æ ¼åç§°ï¼ˆå¦‚ï¼šå°ºå¯¸ã€é‡é‡ï¼‰
  value: string;       // è§„æ ¼å€¼
  unit?: string;       // å•ä½
}

export interface Dimensions {
  length: number;      // é•¿åº¦(mm)
  width: number;       // å®½åº¦(mm)
  height: number;      // é«˜åº¦(mm)
}

export interface PackagingOption {
  id: string;
  name: string;        // åŒ…è£…åç§°
  type: PackagingType; // åŒ…è£…ç±»å‹
  description?: string;
  cost?: number;       // åŒ…è£…æˆæœ¬
}

export type PackagingType = 
  | 'standard'         // æ ‡å‡†åŒ…è£…
  | 'premium'          // ç²¾è£…åŒ…è£…
  | 'gift'            // ç¤¼å“åŒ…è£…
  | 'bulk'            // æ•£è£…
  | 'custom';         // å®šåˆ¶åŒ…è£…
```

#### 3.2.3 é‡‡è´­ç›¸å…³ç±»å‹
```typescript
// src/types/procurement.ts
export interface PurchaseRequest {
  id: string;
  requestNumber: string;           // ç”³è¯·å•å·
  requesterId: string;            // ç”³è¯·äººID
  requester: User;                // ç”³è¯·äººä¿¡æ¯
  items: PurchaseRequestItem[];   // ç”³è¯·é¡¹ç›®
  totalAmount: number;            // æ€»é‡‘é¢
  status: OrderStatus;            // è®¢å•çŠ¶æ€
  approvalStatus: ApprovalStatus; // å®¡æ‰¹çŠ¶æ€
  type?: PurchaseType;           // é‡‡è´­ç±»å‹
  priority: RequestPriority;      // ä¼˜å…ˆçº§
  deadline: Date;                 // æœŸæœ›äº¤æœŸ
  remarks?: string;               // å¤‡æ³¨
  
  // å®¡æ‰¹ä¿¡æ¯
  firstApproverId?: string;
  firstApprover?: User;
  firstApprovalDate?: Date;
  firstApprovalRemarks?: string;
  finalApproverId?: string;
  finalApprover?: User;
  finalApprovalDate?: Date;
  finalApprovalRemarks?: string;
  
  // ç³»ç»Ÿå­—æ®µ
  createdAt: Date;
  updatedAt: Date;
  version: number;                // ç‰ˆæœ¬å·ï¼ˆç”¨äºä¹è§‚é”ï¼‰
}

export interface PurchaseRequestItem {
  id: string;
  skuId: string;
  sku: SKU;
  quantity: number;               // ç”³è¯·æ•°é‡
  unitPrice?: number;             // å•ä»·
  totalPrice?: number;            // æ€»ä»·
  urgency: ItemUrgency;           // ç´§æ€¥ç¨‹åº¦
  remarks?: string;               // å¤‡æ³¨
  status: ItemStatus;             // é¡¹ç›®çŠ¶æ€
  
  // äº§å“ç‰¹å®šä¿¡æ¯
  material?: string;              // ææ–™è¦æ±‚
  packagingMethod?: string;       // åŒ…è£…æ–¹å¼
  specifications?: ItemSpec[];    // è§„æ ¼è¦æ±‚
  
  // ä¾›åº”å•†ä¿¡æ¯ï¼ˆåˆ†é…åå¡«å…¥ï¼‰
  supplierId?: string;
  supplier?: Supplier;
  estimatedCost?: number;         // é¢„ä¼°æˆæœ¬
  deliveryDate?: Date;            // æœŸæœ›äº¤è´§æ—¥æœŸ
  
  // ç³»ç»Ÿå­—æ®µ
  createdAt: Date;
  updatedAt: Date;
}

export interface ItemSpec {
  name: string;
  value: string;
  required: boolean;
}

export type OrderStatus = 
  | 'draft'             // è‰ç¨¿
  | 'submitted'         // å·²æäº¤
  | 'first_approved'    // ä¸€çº§å®¡æ‰¹é€šè¿‡
  | 'approved'          // å·²æ‰¹å‡†
  | 'allocated'         // å·²åˆ†é…
  | 'rejected'          // å·²æ‹’ç»
  | 'in_production'     // ç”Ÿäº§ä¸­
  | 'quality_check'     // è´¨æ£€ä¸­
  | 'ready_to_ship'     // å¾…å‘è´§
  | 'shipped'           // å·²å‘è´§
  | 'completed'         // å·²å®Œæˆ
  | 'cancelled';        // å·²å–æ¶ˆ

export type ApprovalStatus = 
  | 'pending'           // å¾…å®¡æ‰¹
  | 'first_approved'    // ä¸€çº§å®¡æ‰¹é€šè¿‡
  | 'approved'          // æœ€ç»ˆå®¡æ‰¹é€šè¿‡
  | 'rejected';         // å·²æ‹’ç»

export type PurchaseType = 
  | 'external'          // å‚å®¶åŒ…è£…
  | 'in_house';         // è‡ªå·±åŒ…è£…

export type RequestPriority = 
  | 'low'               // ä½ä¼˜å…ˆçº§
  | 'normal'            // æ™®é€š
  | 'high'              // é«˜ä¼˜å…ˆçº§
  | 'urgent';           // ç´§æ€¥

export type ItemUrgency = 
  | 'normal'            // æ­£å¸¸
  | 'urgent'            // ç´§æ€¥
  | 'critical';         // å…³é”®

export type ItemStatus = 
  | 'pending'           // å¾…å®š
  | 'approved'          // å·²æ‰¹å‡†
  | 'rejected'          // å·²æ‹’ç»
  | 'in_progress'       // è¿›è¡Œä¸­
  | 'completed'         // å·²å®Œæˆ
  | 'shipped'           // å·²å‡ºè´§
  | 'received'          // å·²æ”¶è´§
  | 'cancelled';        // å·²å–æ¶ˆ
```

#### 3.2.4 è®¢å•åˆ†é…ç±»å‹
```typescript
// src/types/allocation.ts
export interface OrderAllocation {
  id: string;
  purchaseRequestId: string;      // é‡‡è´­ç”³è¯·ID
  type: PurchaseType;             // åŒ…è£…ç±»å‹
  paymentMethod: PaymentMethod;   // ä»˜æ¬¾æ–¹å¼
  prepaymentAmount?: number;      // é¢„ä»˜å®šé‡‘é‡‘é¢
  creditDate?: Date;              // è´¦æœŸæ—¥æœŸ
  productionDate: Date;           // ç”Ÿäº§æ—¥æœŸ
  deliveryDate: Date;             // äº¤è´§æ—¥æœŸ
  allocationStatus: AllocationStatus; // åˆ†é…çŠ¶æ€
  allocatedBy: string;            // åˆ†é…äººID
  allocatedAt: Date;              // åˆ†é…æ—¶é—´
  
  // çº¸å¡ç›¸å…³
  cardType?: CardType;            // çº¸å¡ç±»å‹
  cardRequirements?: CardRequirement[]; // çº¸å¡è¦æ±‚
  
  // ä¾›åº”å•†ç›¸å…³
  suppliers: AllocationSupplier[]; // ä¾›åº”å•†åˆ†é…
  
  // å¤‡æ³¨å’Œé™„ä»¶
  remarks?: string;
  attachments?: Attachment[];
  
  // ç³»ç»Ÿå­—æ®µ
  createdAt: Date;
  updatedAt: Date;
}

export interface AllocationSupplier {
  skuId: string;
  supplierId: string;
  supplier: Supplier;
  allocatedQuantity: number;
  unitPrice: number;
  totalPrice: number;
  deliveryDate: Date;
  remarks?: string;
}

export interface CardRequirement {
  id: string;
  type: CardType;
  description: string;
  deadline: Date;
  designerId?: string;
  designer?: User;
  status: CardStatus;
  attachments?: Attachment[];
}

export type AllocationStatus = 
  | 'pending'           // å¾…åˆ†é…
  | 'allocated'         // å·²åˆ†é…
  | 'in_production'     // å¾…ç”Ÿäº§
  | 'production_scheduled' // å·²æ’äº§
  | 'pending_receipt'   // å¾…æ”¶è´§
  | 'received'          // å·²æ”¶è´§
  | 'pending_shipment'  // å¾…å‘è´§
  | 'shipped';          // å·²å‘è´§

export type PaymentMethod = 
  | 'payment_on_delivery'  // ä»˜æ¬¾å‘è´§
  | 'cash_on_delivery'     // è´§åˆ°ä»˜æ¬¾
  | 'credit_terms'         // è´¦æœŸ
  | 'advance_payment';     // é¢„ä»˜æ¬¾

export type CardType =
  | 'finished'          // çº¸å¡æˆå“
  | 'design'            // è®¾è®¡ç¨¿
  | 'none'              // ä¸éœ€è¦
  | 'custom';           // å®šåˆ¶

export type CardStatus = 
  | 'pending'           // å¾…è®¾è®¡
  | 'designing'         // è®¾è®¡ä¸­
  | 'review'            // å¾…å®¡æ ¸
  | 'approved'          // å·²æ‰¹å‡†
  | 'production'        // ç”Ÿäº§ä¸­
  | 'completed';        // å·²å®Œæˆ

export interface Attachment {
  id: string;
  name: string;
  url: string;
  type: string;
  size: number;
  uploadedAt: Date;
  uploadedBy: string;
}
```

---

**ç¬¬ä¸€æ‰¹æ–‡æ¡£å·²å®Œæˆï¼**

è¿™æ˜¯åŸºç¡€æ¶æ„çš„è¯¦ç»†æŠ€æœ¯è§„æ ¼ï¼ŒåŒ…å«ï¼š

âœ… **è®¤è¯ç³»ç»Ÿ**ï¼šå®Œæ•´çš„ç™»å½•ã€æƒé™éªŒè¯ã€è§’è‰²ç®¡ç†
âœ… **çŠ¶æ€ç®¡ç†**ï¼šåŸºäºZustandçš„å…¨å±€çŠ¶æ€ï¼ŒåŒ…å«æ‰€æœ‰ä¸šåŠ¡æ•°æ®
âœ… **ç±»å‹ç³»ç»Ÿ**ï¼šè¯¦ç»†çš„TypeScriptæ¥å£å®šä¹‰
âœ… **æŒä¹…åŒ–**ï¼šlocalStorageé›†æˆå’Œæ•°æ®æ¢å¤

**æ¥ä¸‹æ¥éœ€è¦ç¼–å†™å“ªä¸€æ‰¹ï¼Ÿ**

1. **ç¬¬äºŒæ‰¹ï¼šé‡‡è´­æ ¸å¿ƒæµç¨‹** - ä»ªè¡¨æ¿ã€é‡‡è´­ç”³è¯·ã€å®¡æ‰¹ã€åˆ†é…
2. **ç¬¬ä¸‰æ‰¹ï¼šè¿›åº¦è·Ÿè¸ªç³»ç»Ÿ** - å„ç§è¿›åº¦ç®¡ç†æ¨¡å—
3. **ç¬¬å››æ‰¹ï¼šç”Ÿäº§ä¸ä»“å‚¨** - ç”Ÿäº§ã€å…¥åº“ã€è´¨æ£€ã€å‘è´§
4. **ç¬¬äº”æ‰¹ï¼šç®¡ç†ä¸æ”¯æŒ** - è´¢åŠ¡ã€åº“å­˜ã€ä¾›åº”å•†ã€æŠ¥è¡¨

è¯·å‘Šè¯‰æˆ‘ç»§ç»­å“ªä¸€æ‰¹ï¼Œæˆ‘ä¼šä¸ºä½ å†™å‡ºåŒæ ·è¯¦ç»†çš„æŠ€æœ¯æ–‡æ¡£ï¼
