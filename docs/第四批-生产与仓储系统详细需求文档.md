# ä¸€å®¶ç™¾è´§é‡‡è´­ç®¡ç†ç³»ç»Ÿ - ç¬¬å››æ‰¹ï¼šç”Ÿäº§ä¸ä»“å‚¨ç³»ç»Ÿè¯¦ç»†éœ€æ±‚æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯
- **æ–‡æ¡£ç‰ˆæœ¬**: v1.0
- **ç¼–å†™æ—¥æœŸ**: 2025å¹´8æœˆ11æ—¥
- **é€‚ç”¨èŒƒå›´**: ç”Ÿäº§æ’å•ã€å…¥åº“ç™»è®°ã€è´¨æ£€ç®¡ç†ã€å‘è´§å‡ºåº“æ¨¡å—
- **ä¾èµ–å…³ç³»**: ç¬¬ä¸€æ‰¹åŸºç¡€æ¶æ„ã€ç¬¬äºŒæ‰¹é‡‡è´­æ ¸å¿ƒæµç¨‹ã€ç¬¬ä¸‰æ‰¹è¿›åº¦è·Ÿè¸ªç³»ç»Ÿ

---

## ğŸ­ 1. ç”Ÿäº§æ’å•ç³»ç»Ÿ (`production-scheduling/`)

### 1.1 æ¨¡å—æ¦‚è¿°
ç”Ÿäº§æ’å•ç³»ç»Ÿè´Ÿè´£å°†å·²åˆ†é…çš„é‡‡è´­è®¢å•å®‰æ’åˆ°ç”Ÿäº§è®¡åˆ’ä¸­ï¼Œåè°ƒç”Ÿäº§èµ„æºï¼Œç¡®ä¿æŒ‰æ—¶äº¤ä»˜ã€‚

### 1.2 ç»„ä»¶æ¶æ„

#### 1.2.1 ProductionScheduling ä¸»ç»„ä»¶
```typescript
// src/components/production-scheduling/ProductionScheduling.tsx
interface ProductionSchedulingProps {
  filters?: ProductionFilters;
}

interface ProductionFilters {
  status?: ProductionStatus[];
  productionLine?: string;
  dateRange?: DateRange;
  priority?: RequestPriority[];
  searchTerm?: string;
}

interface ProductionCapacity {
  lineId: string;
  lineName: string;
  maxDailyCapacity: number;
  currentLoad: number;
  availableCapacity: number;
  efficiency: number; // äº§çº¿æ•ˆç‡ç™¾åˆ†æ¯”
}

const ProductionScheduling: React.FC<ProductionSchedulingProps> = ({ filters }) => {
  const [schedules, setSchedules] = useState<ProductionSchedule[]>([]);
  const [capacities, setCapacities] = useState<ProductionCapacity[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [selectedSchedules, setSelectedSchedules] = useState<string[]>([]);
  const [showScheduleModal, setShowScheduleModal] = useState<string | null>(null);
  const [calendarView, setCalendarView] = useState(false);

  // å…¨å±€çŠ¶æ€
  const globalSchedules = useProductionSchedules();
  const orderAllocations = useOrderAllocations();
  const { updateProductionSchedule, addProductionSchedule } = useGlobalStore();

  useEffect(() => {
    setIsLoading(true);
    setSchedules(globalSchedules);
    
    // æ¨¡æ‹Ÿäº§çº¿å®¹é‡æ•°æ®
    setCapacities([
      {
        lineId: 'line-001',
        lineName: 'äº§çº¿A',
        maxDailyCapacity: 1000,
        currentLoad: 750,
        availableCapacity: 250,
        efficiency: 95
      },
      {
        lineId: 'line-002',
        lineName: 'äº§çº¿B',
        maxDailyCapacity: 800,
        currentLoad: 600,
        availableCapacity: 200,
        efficiency: 88
      },
      {
        lineId: 'line-003',
        lineName: 'äº§çº¿C',
        maxDailyCapacity: 1200,
        currentLoad: 950,
        availableCapacity: 250,
        efficiency: 92
      }
    ]);
    
    setIsLoading(false);
  }, [globalSchedules]);

  // ç­›é€‰æ•°æ®
  const filteredSchedules = useMemo(() => {
    let filtered = [...schedules];

    if (filters) {
      if (filters.status && filters.status.length > 0) {
        filtered = filtered.filter(schedule => filters.status!.includes(schedule.status));
      }

      if (filters.productionLine) {
        filtered = filtered.filter(schedule => schedule.productionLineId === filters.productionLine);
      }

      if (filters.priority && filters.priority.length > 0) {
        filtered = filtered.filter(schedule => filters.priority!.includes(schedule.priority));
      }

      if (filters.searchTerm) {
        const searchLower = filters.searchTerm.toLowerCase();
        filtered = filtered.filter(schedule =>
          schedule.purchaseRequestNumber.toLowerCase().includes(searchLower) ||
          schedule.items.some(item => 
            item.sku.name.toLowerCase().includes(searchLower) ||
            item.sku.code.toLowerCase().includes(searchLower)
          )
        );
      }
    }

    return filtered;
  }, [schedules, filters]);

  // åˆ›å»ºæ–°çš„ç”Ÿäº§æ’å•
  const handleCreateSchedule = async (allocationId: string, productionData: ProductionScheduleData) => {
    try {
      const allocation = orderAllocations.find(a => a.id === allocationId);
      if (!allocation) {
        throw new Error('è®¢å•åˆ†é…ä¸å­˜åœ¨');
      }

      const newSchedule: ProductionSchedule = {
        id: generateId(),
        purchaseRequestId: allocation.purchaseRequestId,
        purchaseRequestNumber: `PR-${Date.now()}`, // ä»é‡‡è´­ç”³è¯·è·å–
        allocationId: allocation.id,
        productionLineId: productionData.productionLineId,
        productionLine: capacities.find(c => c.lineId === productionData.productionLineId)!,
        items: productionData.items,
        priority: productionData.priority,
        status: 'scheduled',
        scheduledStartDate: productionData.scheduledStartDate,
        scheduledEndDate: productionData.scheduledEndDate,
        estimatedDuration: productionData.estimatedDuration,
        actualStartDate: null,
        actualEndDate: null,
        totalQuantity: productionData.items.reduce((sum, item) => sum + item.plannedQuantity, 0),
        completedQuantity: 0,
        progressPercentage: 0,
        qualityRequirements: productionData.qualityRequirements || [],
        specialInstructions: productionData.specialInstructions,
        assignedOperator: productionData.assignedOperator,
        remarks: productionData.remarks,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      addProductionSchedule(newSchedule);
      
      // æ›´æ–°è®¢å•åˆ†é…çŠ¶æ€
      updateOrderAllocation(allocationId, {
        allocationStatus: 'production_scheduled',
        updatedAt: new Date()
      });

      toast.success('ç”Ÿäº§æ’å•åˆ›å»ºæˆåŠŸ');
    } catch (error) {
      console.error('Failed to create production schedule:', error);
      toast.error('åˆ›å»ºç”Ÿäº§æ’å•å¤±è´¥');
    }
  };

  // æ›´æ–°ç”Ÿäº§çŠ¶æ€
  const handleStatusUpdate = async (scheduleId: string, newStatus: ProductionStatus, data?: any) => {
    try {
      const updates: Partial<ProductionSchedule> = {
        status: newStatus,
        updatedAt: new Date()
      };

      switch (newStatus) {
        case 'in_progress':
          updates.actualStartDate = new Date();
          updates.progressPercentage = 5;
          break;
        case 'paused':
          updates.pauseReason = data?.reason;
          updates.pausedAt = new Date();
          break;
        case 'completed':
          updates.actualEndDate = new Date();
          updates.progressPercentage = 100;
          updates.completedQuantity = updates.totalQuantity;
          break;
        case 'quality_check':
          updates.productionCompletedAt = new Date();
          updates.progressPercentage = 90;
          break;
      }

      updateProductionSchedule(scheduleId, updates);
      
      toast.success('ç”Ÿäº§çŠ¶æ€æ›´æ–°æˆåŠŸ');
    } catch (error) {
      console.error('Failed to update production status:', error);
      toast.error('çŠ¶æ€æ›´æ–°å¤±è´¥');
    }
  };

  // æ›´æ–°ç”Ÿäº§è¿›åº¦
  const handleProgressUpdate = async (scheduleId: string, progressData: ProductionProgressData) => {
    try {
      const schedule = schedules.find(s => s.id === scheduleId);
      if (!schedule) return;

      const completedQuantity = progressData.completedQuantity;
      const progressPercentage = Math.min((completedQuantity / schedule.totalQuantity) * 100, 100);

      updateProductionSchedule(scheduleId, {
        completedQuantity,
        progressPercentage,
        lastProgressUpdate: new Date(),
        progressNotes: progressData.notes,
        updatedAt: new Date()
      });

      // å¦‚æœå®Œæˆåº¦è¾¾åˆ°100%ï¼Œè‡ªåŠ¨æ›´æ–°çŠ¶æ€
      if (progressPercentage >= 100) {
        handleStatusUpdate(scheduleId, 'quality_check');
      }

      toast.success('ç”Ÿäº§è¿›åº¦æ›´æ–°æˆåŠŸ');
    } catch (error) {
      console.error('Failed to update production progress:', error);
      toast.error('è¿›åº¦æ›´æ–°å¤±è´¥');
    }
  };

  const getStatusBadge = (status: ProductionStatus) => {
    const statusConfig = {
      scheduled: { color: 'blue', text: 'å·²æ’äº§' },
      ready: { color: 'yellow', text: 'å‡†å¤‡å¼€å§‹' },
      in_progress: { color: 'green', text: 'ç”Ÿäº§ä¸­' },
      paused: { color: 'orange', text: 'æš‚åœ' },
      quality_check: { color: 'purple', text: 'è´¨æ£€ä¸­' },
      completed: { color: 'emerald', text: 'å·²å®Œæˆ' },
      cancelled: { color: 'gray', text: 'å·²å–æ¶ˆ' }
    };

    const config = statusConfig[status] || statusConfig.scheduled;
    
    return (
      <span className={`
        inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium
        bg-${config.color}-100 text-${config.color}-800
      `}>
        {config.text}
      </span>
    );
  };

  const getPriorityBadge = (priority: RequestPriority) => {
    const priorityConfig = {
      low: { color: 'gray', text: 'ä½', icon: null },
      normal: { color: 'blue', text: 'æ™®é€š', icon: null },
      high: { color: 'yellow', text: 'é«˜', icon: <ExclamationIcon className="h-3 w-3" /> },
      urgent: { color: 'red', text: 'ç´§æ€¥', icon: <ExclamationTriangleIcon className="h-3 w-3" /> }
    };

    const config = priorityConfig[priority];
    
    return (
      <span className={`
        inline-flex items-center space-x-1 px-2 py-1 rounded text-xs font-medium
        bg-${config.color}-100 text-${config.color}-800
      `}>
        {config.icon}
        <span>{config.text}</span>
      </span>
    );
  };

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-600"></div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* é¡µé¢æ ‡é¢˜ */}
      <div className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="py-6">
            <div className="flex items-center justify-between">
              <div>
                <h1 className="text-3xl font-bold text-gray-900">ç”Ÿäº§æ’å•ç®¡ç†</h1>
                <p className="mt-1 text-sm text-gray-500">
                  å®‰æ’å’Œç›‘æ§ç”Ÿäº§è®¡åˆ’ï¼Œä¼˜åŒ–ç”Ÿäº§èµ„æºé…ç½®
                </p>
              </div>
              
              <div className="flex items-center space-x-4">
                {/* è§†å›¾åˆ‡æ¢ */}
                <div className="flex rounded-md shadow-sm">
                  <button
                    onClick={() => setCalendarView(false)}
                    className={`
                      px-4 py-2 text-sm font-medium rounded-l-md border
                      ${!calendarView
                        ? 'bg-blue-600 text-white border-blue-600'
                        : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                      }
                    `}
                  >
                    <ViewListIcon className="h-4 w-4 mr-2 inline" />
                    åˆ—è¡¨è§†å›¾
                  </button>
                  <button
                    onClick={() => setCalendarView(true)}
                    className={`
                      px-4 py-2 text-sm font-medium rounded-r-md border-t border-b border-r
                      ${calendarView
                        ? 'bg-blue-600 text-white border-blue-600'
                        : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'
                      }
                    `}
                  >
                    <CalendarIcon className="h-4 w-4 mr-2 inline" />
                    æ—¥å†è§†å›¾
                  </button>
                </div>

                <button
                  onClick={() => setShowScheduleModal('new')}
                  className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                >
                  <PlusIcon className="h-4 w-4 mr-2" />
                  æ–°å»ºæ’å•
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* äº§çº¿å®¹é‡æ¦‚è§ˆ */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
        <div className="bg-white shadow rounded-lg p-6 mb-6">
          <h3 className="text-lg leading-6 font-medium text-gray-900 mb-4">
            äº§çº¿å®¹é‡æ¦‚è§ˆ
          </h3>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
            {capacities.map((capacity) => (
              <ProductionLineCard
                key={capacity.lineId}
                capacity={capacity}
                schedules={filteredSchedules.filter(s => s.productionLineId === capacity.lineId)}
              />
            ))}
          </div>
        </div>

        {/* ç­›é€‰å™¨ */}
        <ProductionFilters 
          filters={filters}
          capacities={capacities}
          onFiltersChange={(newFilters) => {/* æ›´æ–°ç­›é€‰æ¡ä»¶ */}}
        />

        {/* ä¸»è¦å†…å®¹ */}
        <div className="bg-white shadow rounded-lg">
          {calendarView ? (
            <ProductionCalendar
              schedules={filteredSchedules}
              capacities={capacities}
              onScheduleSelect={(scheduleId) => setShowScheduleModal(scheduleId)}
              onStatusUpdate={handleStatusUpdate}
            />
          ) : (
            <ProductionScheduleList
              schedules={filteredSchedules}
              selectedSchedules={selectedSchedules}
              onSelectionChange={setSelectedSchedules}
              onStatusUpdate={handleStatusUpdate}
              onProgressUpdate={handleProgressUpdate}
              onScheduleEdit={(scheduleId) => setShowScheduleModal(scheduleId)}
            />
          )}
        </div>

        {/* æ‰¹é‡æ“ä½œé¢æ¿ */}
        {selectedSchedules.length > 0 && (
          <ProductionBatchOperationPanel
            selectedCount={selectedSchedules.length}
            onClearSelection={() => setSelectedSchedules([])}
            onBatchUpdate={(updates) => {
              selectedSchedules.forEach(scheduleId => {
                updateProductionSchedule(scheduleId, updates);
              });
              setSelectedSchedules([]);
            }}
          />
        )}
      </div>

      {/* æ’å•æ¨¡æ€æ¡† */}
      {showScheduleModal && (
        <ProductionScheduleModal
          scheduleId={showScheduleModal === 'new' ? null : showScheduleModal}
          capacities={capacities}
          availableAllocations={orderAllocations.filter(a => a.allocationStatus === 'allocated')}
          onSave={handleCreateSchedule}
          onClose={() => setShowScheduleModal(null)}
        />
      )}
    </div>
  );
};

export default ProductionScheduling;
```

#### 1.2.2 ProductionLineCard äº§çº¿å¡ç‰‡ç»„ä»¶
```typescript
// src/components/production-scheduling/ProductionLineCard.tsx
interface ProductionLineCardProps {
  capacity: ProductionCapacity;
  schedules: ProductionSchedule[];
}

const ProductionLineCard: React.FC<ProductionLineCardProps> = ({ capacity, schedules }) => {
  const utilizationPercentage = (capacity.currentLoad / capacity.maxDailyCapacity) * 100;
  
  const todaySchedules = schedules.filter(schedule => {
    const today = new Date();
    const scheduleDate = new Date(schedule.scheduledStartDate);
    return scheduleDate.toDateString() === today.toDateString();
  });

  const inProgressCount = schedules.filter(s => s.status === 'in_progress').length;
  const scheduledCount = schedules.filter(s => s.status === 'scheduled').length;

  const getUtilizationColor = (percentage: number) => {
    if (percentage >= 90) return 'red';
    if (percentage >= 70) return 'yellow';
    return 'green';
  };

  return (
    <div className="border border-gray-200 rounded-lg p-4">
      <div className="flex items-center justify-between mb-3">
        <h4 className="text-lg font-medium text-gray-900">{capacity.lineName}</h4>
        <span className={`
          inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium
          bg-${getUtilizationColor(utilizationPercentage)}-100 
          text-${getUtilizationColor(utilizationPercentage)}-800
        `}>
          {utilizationPercentage.toFixed(1)}% ä½¿ç”¨ç‡
        </span>
      </div>

      {/* å®¹é‡è¿›åº¦æ¡ */}
      <div className="mb-4">
        <div className="flex justify-between text-sm text-gray-600 mb-1">
          <span>ä»Šæ—¥äº§èƒ½</span>
          <span>{capacity.currentLoad}/{capacity.maxDailyCapacity}</span>
        </div>
        <div className="w-full bg-gray-200 rounded-full h-2">
          <div
            className={`h-2 rounded-full bg-${getUtilizationColor(utilizationPercentage)}-500`}
            style={{ width: `${Math.min(utilizationPercentage, 100)}%` }}
          ></div>
        </div>
      </div>

      {/* ç»Ÿè®¡ä¿¡æ¯ */}
      <div className="grid grid-cols-2 gap-4 text-sm">
        <div>
          <div className="text-gray-500">ç”Ÿäº§ä¸­</div>
          <div className="text-lg font-semibold text-green-600">{inProgressCount}</div>
        </div>
        <div>
          <div className="text-gray-500">å·²æ’äº§</div>
          <div className="text-lg font-semibold text-blue-600">{scheduledCount}</div>
        </div>
        <div>
          <div className="text-gray-500">æ•ˆç‡</div>
          <div className="text-lg font-semibold text-gray-900">{capacity.efficiency}%</div>
        </div>
        <div>
          <div className="text-gray-500">ä»Šæ—¥ä»»åŠ¡</div>
          <div className="text-lg font-semibold text-purple-600">{todaySchedules.length}</div>
        </div>
      </div>

      {/* ä»Šæ—¥æ’äº§é¢„è§ˆ */}
      {todaySchedules.length > 0 && (
        <div className="mt-4 pt-4 border-t border-gray-200">
          <h5 className="text-sm font-medium text-gray-700 mb-2">ä»Šæ—¥æ’äº§</h5>
          <div className="space-y-2">
            {todaySchedules.slice(0, 2).map((schedule) => (
              <div key={schedule.id} className="flex items-center justify-between text-sm">
                <span className="text-gray-600 truncate">
                  {schedule.purchaseRequestNumber}
                </span>
                <span className={`
                  inline-flex items-center px-2 py-0.5 rounded text-xs font-medium
                  ${schedule.status === 'in_progress' ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800'}
                `}>
                  {schedule.status === 'in_progress' ? 'è¿›è¡Œä¸­' : 'å¾…å¼€å§‹'}
                </span>
              </div>
            ))}
            {todaySchedules.length > 2 && (
              <div className="text-xs text-gray-500 text-center">
                è¿˜æœ‰ {todaySchedules.length - 2} ä¸ªä»»åŠ¡...
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
};
```

#### 1.2.3 ProductionScheduleList ç”Ÿäº§æ’å•åˆ—è¡¨ç»„ä»¶
```typescript
// src/components/production-scheduling/ProductionScheduleList.tsx
interface ProductionScheduleListProps {
  schedules: ProductionSchedule[];
  selectedSchedules: string[];
  onSelectionChange: (selected: string[]) => void;
  onStatusUpdate: (scheduleId: string, status: ProductionStatus, data?: any) => void;
  onProgressUpdate: (scheduleId: string, progressData: ProductionProgressData) => void;
  onScheduleEdit: (scheduleId: string) => void;
}

const ProductionScheduleList: React.FC<ProductionScheduleListProps> = ({
  schedules,
  selectedSchedules,
  onSelectionChange,
  onStatusUpdate,
  onProgressUpdate,
  onScheduleEdit
}) => {
  const [sortConfig, setSortConfig] = useState<SortConfig>({
    key: 'scheduledStartDate',
    direction: 'asc'
  });

  const [showProgressModal, setShowProgressModal] = useState<string | null>(null);

  // æ’åºæ•°æ®
  const sortedSchedules = useMemo(() => {
    return [...schedules].sort((a, b) => {
      const aValue = getNestedValue(a, sortConfig.key);
      const bValue = getNestedValue(b, sortConfig.key);
      
      if (aValue < bValue) {
        return sortConfig.direction === 'asc' ? -1 : 1;
      }
      if (aValue > bValue) {
        return sortConfig.direction === 'asc' ? 1 : -1;
      }
      return 0;
    });
  }, [schedules, sortConfig]);

  const handleSort = (key: string) => {
    setSortConfig(prev => ({
      key,
      direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc'
    }));
  };

  const handleSelectSchedule = (scheduleId: string, isSelected: boolean) => {
    if (isSelected) {
      onSelectionChange([...selectedSchedules, scheduleId]);
    } else {
      onSelectionChange(selectedSchedules.filter(id => id !== scheduleId));
    }
  };

  const handleSelectAll = (isSelected: boolean) => {
    if (isSelected) {
      onSelectionChange(sortedSchedules.map(schedule => schedule.id));
    } else {
      onSelectionChange([]);
    }
  };

  const getProgressColor = (percentage: number) => {
    if (percentage >= 90) return 'green';
    if (percentage >= 50) return 'blue';
    if (percentage >= 25) return 'yellow';
    return 'gray';
  };

  const isOverdue = (schedule: ProductionSchedule): boolean => {
    const now = new Date();
    return schedule.scheduledEndDate < now && schedule.status !== 'completed';
  };

  if (sortedSchedules.length === 0) {
    return (
      <div className="text-center py-12">
        <ClipboardListIcon className="mx-auto h-12 w-12 text-gray-400" />
        <h3 className="mt-2 text-sm font-medium text-gray-900">æš‚æ— ç”Ÿäº§æ’å•</h3>
        <p className="mt-1 text-sm text-gray-500">
          è¿˜æ²¡æœ‰åˆ›å»ºä»»ä½•ç”Ÿäº§æ’å•
        </p>
      </div>
    );
  }

  return (
    <>
      {/* è¡¨æ ¼æ ‡é¢˜ */}
      <div className="px-6 py-4 border-b border-gray-200 bg-gray-50">
        <div className="flex items-center justify-between">
          <div className="flex items-center">
            <input
              type="checkbox"
              className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
              checked={selectedSchedules.length === sortedSchedules.length && sortedSchedules.length > 0}
              onChange={(e) => handleSelectAll(e.target.checked)}
            />
            <span className="ml-3 text-sm font-medium text-gray-900">å…¨é€‰</span>
          </div>
          <div className="text-sm text-gray-500">
            å…± {sortedSchedules.length} ä¸ªæ’å•
          </div>
        </div>
      </div>

      {/* æ’å•åˆ—è¡¨ */}
      <div className="divide-y divide-gray-200">
        {sortedSchedules.map((schedule) => (
          <div key={schedule.id} className={`
            px-6 py-4 hover:bg-gray-50
            ${isOverdue(schedule) ? 'bg-red-50 border-l-4 border-l-red-500' : ''}
          `}>
            <div className="flex items-start space-x-4">
              <input
                type="checkbox"
                className="mt-1 h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                checked={selectedSchedules.includes(schedule.id)}
                onChange={(e) => handleSelectSchedule(schedule.id, e.target.checked)}
              />
              
              <div className="flex-1 min-w-0">
                {/* æ’å•åŸºæœ¬ä¿¡æ¯ */}
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-3">
                    <button
                      onClick={() => onScheduleEdit(schedule.id)}
                      className="text-sm font-medium text-blue-600 hover:text-blue-900 hover:underline"
                    >
                      {schedule.purchaseRequestNumber}
                    </button>
                    {getStatusBadge(schedule.status)}
                    {getPriorityBadge(schedule.priority)}
                    {isOverdue(schedule) && (
                      <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-100 text-red-800">
                        <ClockIcon className="h-3 w-3 mr-1" />
                        é€¾æœŸ
                      </span>
                    )}
                  </div>
                  <div className="flex items-center space-x-4 text-sm text-gray-500">
                    <span>äº§çº¿ï¼š{schedule.productionLine.lineName}</span>
                    <span>æ•°é‡ï¼š{schedule.totalQuantity}</span>
                  </div>
                </div>

                {/* è¿›åº¦æ¡ */}
                <div className="mt-3">
                  <div className="flex items-center justify-between text-sm mb-1">
                    <span className="text-gray-600">ç”Ÿäº§è¿›åº¦</span>
                    <span className="font-medium">
                      {schedule.completedQuantity}/{schedule.totalQuantity} 
                      ({schedule.progressPercentage.toFixed(1)}%)
                    </span>
                  </div>
                  <div className="w-full bg-gray-200 rounded-full h-2">
                    <div
                      className={`h-2 rounded-full bg-${getProgressColor(schedule.progressPercentage)}-500`}
                      style={{ width: `${schedule.progressPercentage}%` }}
                    ></div>
                  </div>
                </div>

                {/* æ—¶é—´ä¿¡æ¯ */}
                <div className="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-4 text-sm">
                  <div>
                    <span className="font-medium text-gray-700">è®¡åˆ’æ—¶é—´ï¼š</span>
                    <span className="text-gray-600">
                      {formatDate(schedule.scheduledStartDate)} - {formatDate(schedule.scheduledEndDate)}
                    </span>
                  </div>
                  {schedule.actualStartDate && (
                    <div>
                      <span className="font-medium text-gray-700">å®é™…å¼€å§‹ï¼š</span>
                      <span className="text-gray-600">{formatDate(schedule.actualStartDate)}</span>
                    </div>
                  )}
                </div>

                {/* ç”Ÿäº§é¡¹ç›® */}
                <div className="mt-3">
                  <div className="text-xs font-medium text-gray-700 uppercase tracking-wide mb-2">
                    ç”Ÿäº§é¡¹ç›® ({schedule.items.length})
                  </div>
                  <div className="space-y-1">
                    {schedule.items.slice(0, 2).map((item, index) => (
                      <div key={index} className="flex items-center justify-between bg-gray-50 rounded px-3 py-2">
                        <div className="flex items-center space-x-3">
                          <span className="text-sm font-medium text-gray-900">
                            {item.sku.name}
                          </span>
                          <span className="text-xs text-gray-500">
                            {item.sku.code}
                          </span>
                        </div>
                        <div className="text-sm text-gray-600">
                          è®¡åˆ’ï¼š{item.plannedQuantity} | å®Œæˆï¼š{item.completedQuantity || 0}
                        </div>
                      </div>
                    ))}
                    {schedule.items.length > 2 && (
                      <div className="text-center py-1">
                        <button className="text-xs text-blue-600 hover:text-blue-900">
                          æŸ¥çœ‹å…¨éƒ¨ {schedule.items.length} ä¸ªé¡¹ç›®
                        </button>
                      </div>
                    )}
                  </div>
                </div>

                {/* æ“ä½œå‘˜ä¿¡æ¯ */}
                {schedule.assignedOperator && (
                  <div className="mt-3 flex items-center text-sm">
                    <UserIcon className="h-4 w-4 text-gray-400 mr-2" />
                    <span className="font-medium text-gray-700">æ“ä½œå‘˜ï¼š</span>
                    <span className="text-gray-600 ml-1">{schedule.assignedOperator.name}</span>
                  </div>
                )}

                {/* ç‰¹æ®Šè¯´æ˜ */}
                {schedule.specialInstructions && (
                  <div className="mt-3 p-3 bg-yellow-50 border-l-4 border-yellow-400 rounded-r">
                    <div className="text-sm">
                      <span className="font-medium text-yellow-800">ç‰¹æ®Šè¯´æ˜ï¼š</span>
                      <span className="text-yellow-700 ml-1">{schedule.specialInstructions}</span>
                    </div>
                  </div>
                )}
              </div>

              {/* æ“ä½œæŒ‰é’® */}
              <div className="flex flex-col space-y-2">
                {schedule.status === 'scheduled' && (
                  <button
                    onClick={() => onStatusUpdate(schedule.id, 'in_progress')}
                    className="inline-flex items-center px-3 py-2 border border-transparent shadow-sm text-sm leading-4 font-medium rounded-md text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                  >
                    <PlayIcon className="h-4 w-4 mr-1" />
                    å¼€å§‹ç”Ÿäº§
                  </button>
                )}
                
                {schedule.status === 'in_progress' && (
                  <>
                    <button
                      onClick={() => setShowProgressModal(schedule.id)}
                      className="inline-flex items-center px-3 py-2 border border-blue-300 shadow-sm text-sm leading-4 font-medium rounded-md text-blue-700 bg-blue-50 hover:bg-blue-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                    >
                      <RefreshIcon className="h-4 w-4 mr-1" />
                      æ›´æ–°è¿›åº¦
                    </button>
                    
                    <button
                      onClick={() => onStatusUpdate(schedule.id, 'paused', { reason: 'æš‚åœåŸå› ' })}
                      className="inline-flex items-center px-3 py-2 border border-yellow-300 shadow-sm text-sm leading-4 font-medium rounded-md text-yellow-700 bg-yellow-50 hover:bg-yellow-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-yellow-500"
                    >
                      <PauseIcon className="h-4 w-4 mr-1" />
                      æš‚åœ
                    </button>
                  </>
                )}
                
                {schedule.status === 'paused' && (
                  <button
                    onClick={() => onStatusUpdate(schedule.id, 'in_progress')}
                    className="inline-flex items-center px-3 py-2 border border-transparent shadow-sm text-sm leading-4 font-medium rounded-md text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                  >
                    <PlayIcon className="h-4 w-4 mr-1" />
                    ç»§ç»­
                  </button>
                )}
                
                <button
                  onClick={() => onScheduleEdit(schedule.id)}
                  className="inline-flex items-center px-3 py-2 border border-gray-300 shadow-sm text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                >
                  æŸ¥çœ‹è¯¦æƒ…
                </button>
              </div>
            </div>
          </div>
        ))}
      </div>

      {/* ç”Ÿäº§è¿›åº¦æ›´æ–°æ¨¡æ€æ¡† */}
      {showProgressModal && (
        <ProductionProgressModal
          scheduleId={showProgressModal}
          schedule={sortedSchedules.find(s => s.id === showProgressModal)!}
          onSave={(progressData) => {
            onProgressUpdate(showProgressModal, progressData);
            setShowProgressModal(null);
          }}
          onClose={() => setShowProgressModal(null)}
        />
      )}
    </>
  );
};
```

---

## ğŸ“¦ 2. å…¥åº“ç™»è®°ç³»ç»Ÿ (`inbound-register/`)

### 2.1 æ¨¡å—æ¦‚è¿°
å…¥åº“ç™»è®°ç³»ç»Ÿè´Ÿè´£è®°å½•è´§ç‰©åˆ°è¾¾ã€éªŒæ”¶ç™»è®°ã€åº“ä½åˆ†é…ç­‰å…¥åº“ç›¸å…³æ“ä½œã€‚

### 2.2 ç»„ä»¶æ¶æ„

#### 2.2.1 InboundRegister ä¸»ç»„ä»¶
```typescript
// src/components/inbound-register/InboundRegister.tsx
interface InboundRegisterProps {
  filters?: InboundFilters;
}

interface InboundFilters {
  status?: InboundStatus[];
  dateRange?: DateRange;
  warehouse?: string;
  supplier?: string;
  searchTerm?: string;
}

const InboundRegister: React.FC<InboundRegisterProps> = ({ filters }) => {
  const [registers, setRegisters] = useState<InboundRegisterRecord[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [selectedRegisters, setSelectedRegisters] = useState<string[]>([]);
  const [showRegisterModal, setShowRegisterModal] = useState<string | null>(null);
  const [scannerActive, setScannerActive] = useState(false);

  // å…¨å±€çŠ¶æ€
  const globalRegisters = useInboundRegisters();
  const qualityRecords = useQualityControlRecords();
  const { addInboundRegister, updateInboundRegister } = useGlobalStore();

  useEffect(() => {
    setRegisters(globalRegisters);
    setIsLoading(false);
  }, [globalRegisters]);

  // ç­›é€‰æ•°æ®
  const filteredRegisters = useMemo(() => {
    let filtered = [...registers];

    if (filters) {
      if (filters.status && filters.status.length > 0) {
        filtered = filtered.filter(register => filters.status!.includes(register.status));
      }

      if (filters.warehouse) {
        filtered = filtered.filter(register => register.warehouseId === filters.warehouse);
      }

      if (filters.supplier) {
        filtered = filtered.filter(register => register.supplierId === filters.supplier);
      }

      if (filters.searchTerm) {
        const searchLower = filters.searchTerm.toLowerCase();
        filtered = filtered.filter(register =>
          register.purchaseRequestNumber.toLowerCase().includes(searchLower) ||
          register.sku.name.toLowerCase().includes(searchLower) ||
          register.sku.code.toLowerCase().includes(searchLower) ||
          register.lotNumber?.toLowerCase().includes(searchLower)
        );
      }
    }

    return filtered;
  }, [registers, filters]);

  // åˆ›å»ºå…¥åº“ç™»è®°
  const handleCreateRegister = async (registerData: InboundRegisterData) => {
    try {
      const newRegister: InboundRegisterRecord = {
        id: generateId(),
        purchaseRequestNumber: registerData.purchaseRequestNumber,
        purchaseRequestId: registerData.purchaseRequestId,
        skuId: registerData.skuId,
        sku: registerData.sku,
        supplierId: registerData.supplierId,
        supplier: registerData.supplier,
        warehouseId: registerData.warehouseId,
        warehouse: registerData.warehouse,
        expectedQuantity: registerData.expectedQuantity,
        receivedQuantity: registerData.receivedQuantity,
        actualQuantity: registerData.actualQuantity || registerData.receivedQuantity,
        unitPrice: registerData.unitPrice,
        totalValue: (registerData.actualQuantity || registerData.receivedQuantity) * registerData.unitPrice,
        status: 'received',
        receiveDate: new Date(),
        receiverId: getCurrentUser().id,
        receiver: getCurrentUser(),
        lotNumber: registerData.lotNumber,
        expiryDate: registerData.expiryDate,
        storageLocation: registerData.storageLocation,
        packageCount: registerData.packageCount,
        packageType: registerData.packageType,
        weightPerPackage: registerData.weightPerPackage,
        totalWeight: registerData.packageCount * (registerData.weightPerPackage || 0),
        qualityStatus: 'pending',
        remarks: registerData.remarks,
        photos: registerData.photos || [],
        createdAt: new Date(),
        updatedAt: new Date()
      };

      addInboundRegister(newRegister);
      
      // è‡ªåŠ¨åˆ›å»ºè´¨æ£€è®°å½•
      if (registerData.autoCreateQualityCheck) {
        await createQualityCheckRecord(newRegister);
      }

      toast.success('å…¥åº“ç™»è®°åˆ›å»ºæˆåŠŸ');
    } catch (error) {
      console.error('Failed to create inbound register:', error);
      toast.error('åˆ›å»ºå…¥åº“ç™»è®°å¤±è´¥');
    }
  };

  // æ›´æ–°å…¥åº“çŠ¶æ€
  const handleStatusUpdate = async (registerId: string, newStatus: InboundStatus, data?: any) => {
    try {
      const updates: Partial<InboundRegisterRecord> = {
        status: newStatus,
        updatedAt: new Date()
      };

      switch (newStatus) {
        case 'quality_checked':
          updates.qualityCheckDate = new Date();
          updates.qualityStatus = data?.qualityStatus || 'passed';
          break;
        case 'stored':
          updates.storedDate = new Date();
          updates.finalStorageLocation = data?.storageLocation;
          break;
        case 'rejected':
          updates.rejectionReason = data?.reason;
          updates.rejectionDate = new Date();
          break;
      }

      updateInboundRegister(registerId, updates);
      
      toast.success('çŠ¶æ€æ›´æ–°æˆåŠŸ');
    } catch (error) {
      console.error('Failed to update status:', error);
      toast.error('çŠ¶æ€æ›´æ–°å¤±è´¥');
    }
  };

  // æ‰¹é‡å…¥åº“ç™»è®°
  const handleBatchRegister = async (batchData: BatchInboundData) => {
    try {
      const registerPromises = batchData.items.map(item => 
        handleCreateRegister({
          ...batchData.common,
          ...item
        })
      );

      await Promise.all(registerPromises);
      
      toast.success(`æ‰¹é‡ç™»è®° ${batchData.items.length} ä¸ªé¡¹ç›®æˆåŠŸ`);
    } catch (error) {
      console.error('Failed to batch register:', error);
      toast.error('æ‰¹é‡ç™»è®°å¤±è´¥');
    }
  };

  // æ¡ç æ‰«æå¤„ç†
  const handleBarcodeScanned = async (barcode: string) => {
    try {
      // æ ¹æ®æ¡ç æŸ¥æ‰¾å¯¹åº”çš„é‡‡è´­ç”³è¯·å’ŒSKUä¿¡æ¯
      const skuInfo = await lookupSKUByBarcode(barcode);
      
      if (skuInfo) {
        // è‡ªåŠ¨å¡«å……æ‰«æåˆ°çš„å•†å“ä¿¡æ¯
        setShowRegisterModal('scan');
        // è¿™é‡Œå¯ä»¥é¢„å¡«å……è¡¨å•æ•°æ®
      } else {
        toast.error('æœªæ‰¾åˆ°å¯¹åº”çš„å•†å“ä¿¡æ¯');
      }
    } catch (error) {
      console.error('Failed to process barcode:', error);
      toast.error('æ¡ç æ‰«æå¤±è´¥');
    }
  };

  const getStatusBadge = (status: InboundStatus) => {
    const statusConfig = {
      received: { color: 'blue', text: 'å·²æ”¶è´§' },
      quality_checking: { color: 'yellow', text: 'è´¨æ£€ä¸­' },
      quality_checked: { color: 'green', text: 'è´¨æ£€å®Œæˆ' },
      stored: { color: 'emerald', text: 'å·²å…¥åº“' },
      rejected: { color: 'red', text: 'å·²æ‹’æ”¶' }
    };

    const config = statusConfig[status] || statusConfig.received;
    
    return (
      <span className={`
        inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium
        bg-${config.color}-100 text-${config.color}-800
      `}>
        {config.text}
      </span>
    );
  };

  const getQualityStatusBadge = (qualityStatus: QualityStatus) => {
    const statusConfig = {
      pending: { color: 'gray', text: 'å¾…è´¨æ£€' },
      passed: { color: 'green', text: 'è´¨æ£€é€šè¿‡' },
      failed: { color: 'red', text: 'è´¨æ£€ä¸åˆæ ¼' },
      partial: { color: 'yellow', text: 'éƒ¨åˆ†åˆæ ¼' }
    };

    const config = statusConfig[qualityStatus] || statusConfig.pending;
    
    return (
      <span className={`
        inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium
        bg-${config.color}-100 text-${config.color}-800
      `}>
        {config.text}
      </span>
    );
  };

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-600"></div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* é¡µé¢æ ‡é¢˜ */}
      <div className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="py-6">
            <div className="flex items-center justify-between">
              <div>
                <h1 className="text-3xl font-bold text-gray-900">å…¥åº“ç™»è®°ç®¡ç†</h1>
                <p className="mt-1 text-sm text-gray-500">
                  è®°å½•è´§ç‰©åˆ°è¾¾ã€éªŒæ”¶å’Œå…¥åº“ä¿¡æ¯
                </p>
              </div>
              
              <div className="flex items-center space-x-4">
                <InboundStats data={filteredRegisters} />
                
                {/* æ¡ç æ‰«ææŒ‰é’® */}
                <button
                  onClick={() => setScannerActive(!scannerActive)}
                  className={`
                    inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2
                    ${scannerActive
                      ? 'text-red-700 bg-red-100 hover:bg-red-200 focus:ring-red-500'
                      : 'text-blue-700 bg-blue-100 hover:bg-blue-200 focus:ring-blue-500'
                    }
                  `}
                >
                  <QrcodeIcon className="h-4 w-4 mr-2" />
                  {scannerActive ? 'åœæ­¢æ‰«æ' : 'æ¡ç æ‰«æ'}
                </button>

                <button
                  onClick={() => setShowRegisterModal('batch')}
                  className="inline-flex items-center px-4 py-2 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                >
                  <CollectionIcon className="h-4 w-4 mr-2" />
                  æ‰¹é‡ç™»è®°
                </button>

                <button
                  onClick={() => setShowRegisterModal('new')}
                  className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                >
                  <PlusIcon className="h-4 w-4 mr-2" />
                  æ–°å»ºç™»è®°
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* æ¡ç æ‰«æå™¨ */}
      {scannerActive && (
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
          <BarcodeScanner
            onScan={handleBarcodeScanned}
            onError={(error) => {
              console.error('Barcode scan error:', error);
              toast.error('æ¡ç æ‰«æå‡ºé”™');
            }}
          />
        </div>
      )}

      {/* ç­›é€‰å™¨ */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
        <InboundFilters
          filters={filters}
          onFiltersChange={(newFilters) => {/* æ›´æ–°ç­›é€‰æ¡ä»¶ */}}
        />
      </div>

      {/* ä¸»è¦å†…å®¹ */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pb-8">
        <div className="bg-white shadow rounded-lg">
          {/* æ‰¹é‡æ“ä½œæ  */}
          {selectedRegisters.length > 0 && (
            <InboundBatchOperationPanel
              selectedCount={selectedRegisters.length}
              onClearSelection={() => setSelectedRegisters([])}
              onBatchUpdate={(updates) => {
                selectedRegisters.forEach(registerId => {
                  updateInboundRegister(registerId, updates);
                });
                setSelectedRegisters([]);
              }}
            />
          )}

          {/* å…¥åº“ç™»è®°åˆ—è¡¨ */}
          <InboundRegisterList
            registers={filteredRegisters}
            selectedRegisters={selectedRegisters}
            onSelectionChange={setSelectedRegisters}
            onStatusUpdate={handleStatusUpdate}
            onRegisterEdit={(registerId) => setShowRegisterModal(registerId)}
          />
        </div>
      </div>

      {/* å…¥åº“ç™»è®°æ¨¡æ€æ¡† */}
      {showRegisterModal && (
        <InboundRegisterModal
          registerId={showRegisterModal === 'new' || showRegisterModal === 'batch' || showRegisterModal === 'scan' ? null : showRegisterModal}
          mode={showRegisterModal === 'batch' ? 'batch' : 'single'}
          onSave={showRegisterModal === 'batch' ? handleBatchRegister : handleCreateRegister}
          onClose={() => setShowRegisterModal(null)}
        />
      )}
    </div>
  );
};

export default InboundRegister;
```

---

**ç¬¬å››æ‰¹æ–‡æ¡£å·²å®Œæˆï¼**

ç°åœ¨è®©æˆ‘ç»§ç»­ç¼–å†™ç¬¬äº”æ‰¹ï¼šç®¡ç†ä¸æ”¯æŒç³»ç»Ÿï¼Œè¿™å°†æ˜¯æœ€åä¸€æ‰¹ã€‚ç»§ç»­ç¬¬äº”æ‰¹ï¼Ÿ
